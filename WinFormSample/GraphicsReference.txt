/**
 *@title WinFormGUI/WinFormSample/GraphicsReference.txt
 *@copyFrom KT07_Graphics / MainPenDrawLineSample.cs
 *@copyFrom KT07_Graphics / MainDrawFillSample.cs
 *@copyFrom Viewer        / MainHatchBrushViewer.cs
 *@copyFrom KT07_Graphics / MainBrushAppendix.cs
 *@copyFrom KT07_Graphics / MainGraphicsPathSample.cs
 *@copyFrom RR08_Graphics / MainPathGradientBrushSample.cs
 *@copyFrom KT07_Graphics / MainDrawIconSample.cs
 *@copyFrom KT07_Graphics / MainBitmapGetPixcelSample.cs
 *@copyFrom KT07_Graphics / MainBitmapMakeTransparentSample.cs
 *@copyFrom KT07_Graphics / MainBitmapSetPixcelSample.cs
 *@copyFrom KT07_Graphics / MainDrawImageSample.cs
 *@copyFrom RR08_Graphics / MainColorMatrixSemiTransParent.cs
 *@copyFrom RR08_Graphics / MainMatrixRotateSample.cs
 *@copyFrom RR08_Graphics / MainMatrixScaleTaranslate.cs 
 *@copyFrom KT07_Graphics / MainMouseDragSample.cs 
 *@copyFrom KT07_Graphics / MainTimerAnimationSample.cs 
 *@copyFrom KT07_Graphics / MainBallGravity.cs
 *@copyFrom  
 *@author shika
 *@date 2022-09-03
 */
 /* 
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainPenDrawLineSample.cs
 *@content KT07 Graphics | RR[5] p31, RR[366] p616
 *@subject ◆Graphics : MarshalByRefObject, IDisposable, IDeviceContext
 *             -- System.Drawing
 *         ・GDI+ (Graphics Device Interface): C言語で記述されたグラフィックス機能を内部的に呼出
 *         ・描画キャンバスのような存在
 *         ・グラフィックス処理を行うためには、
 *           描画対象の Form, Controlに関連付けた Graphicsオブジェクトを取得する必要がある
 *         ・Controlは PictureBoxなど, Bitmapクラスも可
 *         ・描画対象に結び付けられた Graphics オブジェクトは，
 *           その描画対象の Paint イベントハンドラの引数 PaintEventArgs e から取得可。
 *         ・PaintEventHandlerは control.Paint += new PaintEventHandler(...); が必要
 *         ・OnPaint()を overrideする場合は 「+=」で追加する必要はないが、
 *           base.OnPaint(e);で基底クラスのイベントハンドラも呼び出す必要がある。
 *         
 *         PaintEventHandler   control.Paint
 *           └ delegate void Paint(object sender, PaintEventArgs e)
 *                ||
 *         protected vertural void control.OnPaint(PaintEventArgs e)   virtualを overrideして利用
 *           
 *         PaintEventArgsクラス e -- System.Windows.Forms. 再描画イベントに関するデータを提供
 *         Graphics   e.Graphics
 *         
 *         Graphics   control.CreateGraphics()   // Paint イベントハンドラ以外の場所で Graphics オブジェクトを取得したい場合に利用
 *                                               // CreateGraphics()で生成した描画は、Form/Controlが再描画される際に消えてしまう
 *                                               // => PaintEventArgsから Graphicsオブジェクトを取得すべき
 *                                               // => Bitmapオブジェクトに描画して保存する方法もある
 *
 *         Graphics   Graphics.FromImage(Image)  // Bitmapオブジェクトを生成して、そこに描画
 *                      └ 引数 Image <- new Bitmap(pictureBox.Width, pictureBox.Height)
 *         
 *         [×] new Graphics() の定義なく不可
 *         
 *         ＊プロパティ
 *         float      graphics.DpiX { get; }            X方向の DPI(解像度)
 *         float      graphics.DpiY { get; }            Y方向の DPI(解像度)
 *         Matrix     graphics.Transform { get; set; }  図形変形の行列を登録
 *                    => 〔RR08_Graphics/MainMatrixRotateSample.cs〕
 *         
 *         Region     graphics.Clip { get; set; }       描画の部分取得
 *                    => 〔KT07_Graphics/MainGraphicsPathSample.cs〕
 *         
 *         SmoothingMode  graphics.SmoothingMode { get; set; }
 *           └ enum SmoothingMode  直線、曲線、塗りつぶし領域の境界線に、スムージング (アンチエイリアス処理) を適用するか
 *                    -- System.Drawing.Drawing2D.
 *             {
 *                 Invalid = -1,    //無効なモード
 *                 Default = 0,     //アンチエイリアス処理しない
 *                 HighSpeed = 1,   //アンチエイリアス処理しない
 *                 HighQuality = 2, //アンチエイリアス処理されたレタリングを指定
 *                 None = 3,        //アンチエイリアス処理しない
 *                 AntiAlias = 4    //アンチエイリアス処理されたレタリングを指定
 *             }
 *         
 *         ＊描画制御
 *         void       graphics.Clear(Color)              Graphicsオブジェクトに描画を引数 Colorで塗りつぶす
 *                      └ Color  SystemColors.Windows    => 〔MainDrawFillSample.cs〕
 *         void       graphics.Flush([FlushIntention])   保留中の Graphics操作を強制実行
 *           └ enum FlushIntention  -- System.Drawing.Drawing2D
 *             {
 *                Flush = 0,  //Graphics操作の Stackをすぐに実行し、制御は すぐに戻す
 *                Sync = 1    //できる限り早く実行し、制御は処理完了まで同期的に待機してから戻す
 *             }
 *         void       graphics.Dispose()      CreateGraphics()で生成した Graphicsオブジェクトは 使い終わる度に破棄すべき
 *       ( void       control.Invalidate()    PictureBoxなどを一旦破棄し、再描画 )
 *       ( void       control.Refresh()       キャッシュを破棄し最新の状態を表示  )
 *         
 *         ＊Graphics状態の保存/復元
 *         GraphicsState  graphics.Save()
 *           └ class GraphicsState : MarshalByRefObject    中身のないクラス。名前をつけてその時点の Graphics状態を表す
 *                        -- System.Drawing.Drawing2D
 *         void           graphics.Restore(GraphicsState)  Save()で保存した状態を復元
 *         GraphicsContainer  graphics.BeginContainer(Rectangle dstrect, Rectangle srcrect, GraphicsUnit)
 *                      └ 引数 dstrect:  表示領域
 *                             srcrect:  部分領域, Save()と同様の機能だが、部分領域を抽出できる
 *           └ class GraphicsContainer : MarshalByRefObject  中身のないクラス。名前をつけてその時点の Graphics状態を表す
 *                        -- System.Drawing.Drawing2D
 *         void           graphics.EndContainer(GraphicsContainer)   //BeginContainer()で保存した状態を復元
 *           
 *         ＊直線の描画
 *         void  graphics.DrawLine(Pen, Point p1, Point p2)             始点 p1 から 終点 p2 の直線を描画  ※PointF 可
 *         void  graphics.DrawLine(Pen, int x1, int y1, int x2, int y2) 始点 (x1, y1) から 終点 (x2, y2) の直線を描画  ※ float  可
 *         void  graphics.DrawLines(Pen, Point[])                        複数の直線を描画  ※ PointF[] 可
 *         
 *@subject ◆Penクラス : MarshalByRefObject, ICloneable, IDisposable
 *             -- System.Drawing.
 *         ・Pen クラスを用いて，特定の色と太さを持つ，仮想のペンを定義
 *         ・自己定義した Pen オブジェクトは，使い終る度に Dispose メソッドで破棄する
 *         
 *         Pen   　new Pen(Color)
 *         Pen     new Pen(Color, float width)
 *         Pen   　new Pen(Brush)
 *         Pen     new Pen(Bursh, float width)
 *         Pen     Pens.Xxxx      標準色 Xxxxを指定 Pens struct
 *         
 *         Color      pen.Color
 *         Brush      pen.Brush
 *         float      pen.Width
 *         LineCap    pen.StartCap    線の始点の形状
 *         LineCap    pen.EndCap      線の終点の形状
 *           └ enum LineCap  -- System.Drawing.Drawing2D.
 *             {
 *                 Flat = 0,           //平坦なラインキャップ
 *                 Square = 1,         //四角形のラインキャップ
 *                 Round = 2,          //丸いラインキャップ
 *                 Triangle = 3,       //三角形のラインキャップ
 *                 NoAnchor = 16,      //アンカーなし
 *                 SquareAnchor = 17,  //四角形のアンカー ラインキャップ
 *                 RoundAnchor = 18,   //丸いアンカーキャップ
 *                 DiamondAnchor = 19, //菱形のアンカーキャップ
 *                 ArrowAnchor = 20,   //矢印形のアンカーキャップ
 *                 AnchorMask = 240,   //ラインキャップがアンカーキャップかどうかをチェックする際に使用するマスクを指定
 *                 Custom = 255        //CustomLineCapクラスで定義
 *             }
 *             
 *         DashStyle  pen.DashStyle  
 *           └ enum DashStyle  -- System.Drawing.Drawing2D.
 *             {
 *                Solid = 0,      //実線
 *                Dash = 1,       //ダッシュ「―」で構成される直線
 *                Dot = 2,        //ドット「・」で構成される直線
 *                DashDot = 3,    //ダッシュとドットの繰り返しパターン
 *                DashDotDot = 4, //ダッシュと 2つのドットの繰り返しパターン
 *                Custom = 5      //ユーザー定義のカスタム ダッシュ スタイル
 *             }
 *         float[]    pen.DashPattern   DashStyle.Customのとき
 *                                      破線内の代替ダッシュと空白の長さを指定する実数の配列。
 *                                      =>〔Viewer/MainPenDashStyleViewer.cs〕

 *         DashCap    pen.DashCap       破線の両端の形状
 *           └ enum DashCap { Flat = 0, Round = 1, Triangle = 2 }   -- System.Drawing.Drawing2D.
 *         
 *         float[]    pen.CompoundArray 平行線の複線。0 ～ 1 の値を昇順に並べた配列
 *                                      配列要素の値は Pen.Widthに対する割合で、実線部分の始点、終点で指定
 *                                      例 Pen.Width を 100 %として
 *                                      1本目 0 - 30 %, 2本目　70 - 100 % => 0.0f, 0.3f, 0.7f, 1.0f 
 *                                      =>〔Viewer/MainPenDashStyleViewer.cs〕
 *         LineJoin   pen.LineJoin
 *           └ enum LineJoin
 *             {
 *                 Miter = 0,   //鋭角接合。マイタ制限値を超えている場合は、クリッピング
 *                 Bevel = 1,   //面取り接合。 斜めになった角
 *                 Round = 2,   //角丸接合
 *                 MiterClipped = 3  //鋭角接合。マイタ制限値を超えている場合は、斜めになった角
 *             }
 *         float      pen.MiterLimit  マイタ隅の接合部の太さの限度。常に 1.0f以上の正数。デフォルト 10.0f
 *                       
 *                       ※ Miter表示: 折れ線箇所を面取りしないで尖らせたまま表示すること
 *                       http://www.htmq.com/canvas/miterLimit.shtml
 *                       miterLimit属性は、線の接合箇所をmiter表示にする（折れ線箇所を面取りしないで尖らせる）限界を指定する際に使用します。
 *                       lineJoin属性の値が miter（初期値）の場合、２つの線分が接合する箇所はmiter表示になりますが、 
 *                       この際、２つの線分の接合角度が鋭角であるほど、尖った部分が鋭く長く飛び出すことになります。
 *                       miterLimit属性では、接合箇所がどのくらい尖っている場合にmiter表示にするか、
 *                       あるいは、bevel表示（面取り）にするかの限界値を任意の数値で指定することができます。
 *                       miterLimit属性の値には、lineWidth属性で指定する線幅の半分の長さに対する比率を指定します。
 *                       例えば、lineWidth=20の線分に対してmiterLimit=2.0を指定した場合には、10×2.0＝20となります。
 *                       この例の場合、尖った部分の距離が20を超えない箇所はmiter表示（留め継ぎ）、
 *                       尖った部分の距離が20を超えて飛び出す箇所はbevel表示（面取り）となります。
 *                       =>〔~/Reference/miterLimit001.gif, miterLimit002.gif〕
 *                       
 *         Matrix     pen.Transform   図形変形のための行列を登録 
 *                                    =>〔RR08_Graphics/MainMatrixRotateSample.cs〕
 *         void       pen.Dispose()
 *         
 *@subject ◆SystemPens class -- System.Drawing.
 *         ・Windows System32で使用している色による Penオブジェクトを取得
 *
 *         Pen   SystemPens.ActiveBorder  { get; }
 *         Pen   SystemPens.ActiveCaption  { get; }
 *         Pen   SystemPens.ActiveCaptionText  { get; }
 *         Pen   SystemPens.AppWorkspace  { get; }
 *         Pen   SystemPens.ButtonFace  { get; }
 *         Pen   SystemPens.ButtonHighlight  { get; }
 *         Pen   SystemPens.ButtonShadow  { get; }
 *         Pen   SystemPens.Control  { get; }
 *         Pen   SystemPens.ControlText  { get; }
 *         Pen   SystemPens.ControlDark  { get; }
 *         Pen   SystemPens.ControlDarkDark  { get; }
 *         Pen   SystemPens.ControlLight  { get; }
 *         Pen   SystemPens.ControlLightLight  { get; }
 *         Pen   SystemPens.Desktop  { get; }
 *         Pen   SystemPens.GradientActiveCaption  { get; }
 *         Pen   SystemPens.GradientInactiveCaption  { get; }
 *         Pen   SystemPens.GrayText  { get; }
 *         Pen   SystemPens.Highlight  { get; }
 *         Pen   SystemPens.HighlightText  { get; }
 *         Pen   SystemPens.HotTrack  { get; }
 *         Pen   SystemPens.InactiveBorder  { get; }
 *         Pen   SystemPens.InactiveCaption  { get; }
 *         Pen   SystemPens.InactiveCaptionText  { get; }
 *         Pen   SystemPens.Info  { get; }
 *         Pen   SystemPens.InfoText  { get; }
 *         Pen   SystemPens.Menu  { get; }
 *         Pen   SystemPens.MenuBar  { get; }
 *         Pen   SystemPens.MenuHighlight  { get; }
 *         Pen   SystemPens.MenuText  { get; }
 *         Pen   SystemPens.ScrollBar  { get; }
 *         Pen   SystemPens.Window  { get; }
 *         Pen   SystemPens.WindowFrame  { get; }
 *         Pen   SystemPens.WindowText  { get; }
 */
/*
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainDrawFillSample.cs
 *@subject ◆Graphics -- System.Drawing.
 *         ＊長方形 Rectangle: 始点, 横幅, 高さを指定
 *         void   graphics.DrawRectangle(Pen, Rectangle)
 *         void   graphics.DrawRectangle(Pen, int x, int y, int width, int height)
 *         void   graphics.DrawRectangle(Pen, float x, float y, float width, float height)
 *         void   graphics.DrawRectangles(Pen, Rectangle[]);
 *         void   graphics.DrawRectangles(Pen, RectangleF[]);
 *         
 *         ＊多角形 Polygon: 点となる配列を指定
 *         void   graphics.DrawLines(Pen, Point[])    始点と終点は結合せず
 *         void   graphics.DrawLines(Pen, PointF[])
 *         void   graphics.DrawPolygon(Pen, Point[])  始点と終点を結合し、閉じた多角形を描画
 *         void   graphics.DrawPolygon(Pen, PointF[])
 *         
 *         ＊楕円 Ellipse: 四角形を指定して、それに内接する。正方形なら円、長方形なら楕円になる
 *                        傾いた楕円を描画することはできない => 図形を回転 〔Matrixクラス | RR[374] p630〕
 *         void   graphics.DrawEllipse(Pen, Rectangle)
 *         void   graphics.DrawEllipse(Pen, RectangleF)
 *         void   graphics.DrawEllipse(Pen, int x, int y, int width, int height)
 *         void   graphics.DrawEllipse(Pen, float x, float y, float width, float height)
 *         
 *         ＊おうぎ型 Pie: 元になる楕円の外接四角形を指定し、X軸からの始まり角、終辺の角を度単位で指定 
 *         void   graphics.DrawPie(Pen, Rectangle, float startAngle, float sweepAngle)
 *         void   graphics.DrawPie(Pen, RectangleF, float startAngle, float sweepAngle)
 *         void   graphics.DrawPie(Pen, int x, int y, int width, int height, float startAngle, float sweepAngle)
 *         void   graphics.DrawPie(Pen, float x, float y, float width, float height, float startAngle, float sweepAngle)
 *         
 *         ＊円, 楕円の弧 Arc: 楕円の外接四角形、開始角、回転角を指定して弧を描画
 *         void   graphics.DrawArc(Pen, Rectangle, float startAngle, float sweepAngle) 
 *                  └ 引数 startAngle: 開始角。X軸を 0°とした度単位
 *                         sweepAngle: 回転角。開始角からの角度。度単位
 *                    ※ RectangleF, int, float 可
 *                    
 *         ＊ベジエ曲線 Bezier curve: 
 *         https://e-words.jp/w/%E3%83%99%E3%82%B8%E3%82%A7%E6%9B%B2%E7%B7%9A.html
 *         n個の点（制御点という）の座標を指定すると、n-1次の多項式によって示される。
 *         この曲線は始点と終点を通り、始点とその隣の制御点を結ぶ直線、
 *         および、終点とその隣の制御点を結ぶ直線の両方に接する。
 *         始点と終点の位置が同じでも、途中の制御点の位置を変更することで曲線の形を任意に変形することができる。
 *         作図ソフトなどでは4つの点（始点・終点と中間に2つの制御点）によって描画される3次ベジェ曲線がよく利用される。
 *         
 *         void   graphics.DrawBezier(Pen, Point, Point, Point, Point)
 *         void   graphics.DrawBeziers(Pen, Point[])
 *                ※PointF, PointF[] 可
 *
 *         ＊曲線の図形 ClosedCurve: 指定したPoint, tension(=張り度合?)で曲線の閉じられた図形
 *         void DrawClosedCurve(Pen, Point[], [float tension, FillMode])
 *              ※ PointF[] 可
 *              └ 引数 tension: 0.0f以上 (正のfloat値)
 *                      fillMode: 塗りつぶしの方法
 *               └ enum FillMode -- System.Drawing.Drawing2D.
 *                 {
 *                     Alternate = 0, //交互塗りつぶしモード
 *                     Winding = 1    //全域塗りつぶしモード
 *                 }
 *         ＊曲線
 *         void DrawCurve(Pen, Point[], [int offset, int numberOfSegments,][float tension])
 *              ※ PointF[] 可
 *              引数  int offsetoffset:     Point[]の最初の要素から、描画開始点までのオフセット値(=非描画部分)
 *                    int numberOfSegments  曲線に含めるセグメント値(？)
 *                    float tension         曲線の張り度合 
 *         
 *@subject 塗りつぶし
 *         ＊長方形 (rectangle) 塗りつぶし
 *         void   graphics.FillRectangle(Brush, Rectangle)
 *         void   graphics.FillRectangle(Brush, RectangleF)
 *         void   graphics.FillRectangle(Brush, int x, int y, int width, int height)
 *         void   graphics.FillRectangle(Brush, float x, float y, float width, float height)
 *         void   graphics.FillRectangles(Brush, Rectangle[])
 *         void   graphics.FillRectangles(Brush, RectangleF[])
 *         
 *         ＊楕円 (ellipse) 塗りつぶし
 *         void   graphics.FillEllipse(Brush, Rectangle)
 *         void   graphics.FillEllipse(Brush, RectangleF)
 *         void   graphics.FillEllipse(Brush, int x, int y, int width, int height)
 *         void   graphics.FillEllipse(Brush, float x, float y, float width, float height)
 *
 *         ＊その他 Fill
 *         void   graphics.FillPolygon(Brush, Point[], [FillMode])  ※ PointF[] 可
 *         void   graphics.FillPie(Brush, Rectangle, float startAngle, float sweepAngle) ※ int, float可
 *         void   graphics.FillClosedCurve(Brush, Point[], [FillMode], [float tension])  ※ PointF[] 可 
 *         
 *         ＊GraphicsPathを描画
 *         void   graphics.DrawPath(Pen, GraphicsPath)   =>〔MainGrapicsPathSample.cs〕
 *         void   graphics.FillPath(Brush, GraphicsPath)
 *
 *         ＊Graphics 切替
 *         void   graphics.Clear(Color) =>〔RR08_Graphics/MainPathGradientBrush.cs〕
 *                    └ 引数 Color  SystemColors.Window
 *                  Graphicsオブジェクトに以前に描画したものは残り続けるので、
 *                  画面を切り替える場合は 別の Graphicsオブジェクトに描画するか、
 *                  同一Graphicsなら Clear()して使う
 *                  
 *@NOTE【考察】DrawXxxx() と FillXxxx()の順
 *      輪郭をきれいに描画するには、Fill -> Draw の順がいい
 *      (逆だと、輪郭線が消えて塗りつぶしだけが見える)
 *      
 *@subject abstract Brush =>〔~/WinFormSample/ColorRefernce.txt〕
 *         ＊GDI+(= System.Drawing.Graphics)以外のライブラリ(=System.Drawing.Drawing2D)を利用する Unmangedリソース
 *         ・SolidBrushクラス : Brush           単色ブラシ
 *         ・HatchBrushクラス : Brush           enum HatchStyleで規定の柄で塗りつぶし
 *         ・TextureBrushクラス : Brush         イメージを指定して塗りつぶし
 *         ・LinierGradientBrushクラス : Brush  線形グラデーション
 *             これらのBrushオブジェクトは自動破棄が行われず、アプリケーション実行の間、メモリを占有し続ける。
 *             Brushオブジェクトを大量に利用する場合は、メモリ領域を圧迫する可能性があるので、
 *             利用が終了するたびに Dispose()しておく
 *             =>〔MainBrushAppendix.cs〕
 *         ・PathGradientBrushクラス : Brush    自由図形グラデーション
 *             =>〔RR08_Graphics/MainPathGradientBrushSample.cs〕
 */    
 /* 
 *@title WinFormGUI / WinFormSample / Viewer
 *@class MainHatchBrushViewer.cs
 *@subject Graphics -- System.Drawing.
 *         ・画像外なら Labelでも可
 *         ・DrawString()は 画像内に 画像としての文字列を描画 (重ねる場合は、要 透過色)
 *         
 *         void  graphics.DrawString(string, Font, Brush, PointF)
 *         void  graphics.DrawString(
 *                 string, Font, Brush,
 *                 RectangleF, [StringFormat])
 *         Region[]  graphics.MeasureCharacterRanges(            指定した文字列内のそれぞれの文字位置の範囲に外接する Region
 *                       string, Font, RectangleF, StringFormat)
 *         SizeF  graphics.MeasureString(                        文字列が描画された領域を返す
 *                       string, Font, [SizeF], [StringFormat])  ※ PointF[], int width 可
 */
 /* 
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainBrushAppendix.cs
 *@subject ◆LinearGradientBrush : Brush  -- System.Drawing.Drawing2D.
 *         ・線形グラデーション: 一定割合で、一方向へ色の濃淡を変化
 *         ・コンストラクタで、四角形, 開始色, 終了色, Mode, 
 *           [角度][角度の影響を受けるか]を設定
 *         LinearGradientBrush    new LinearGradientBrush(
 *             PointF, PointF, Color, Color, LinearGradientMode
 *             [, float angle, [bool isAngleScaleable]])
 *         LinearGradientBrush    new LinearGradientBrush(
 *             RectangleF, Color, Color, LinearGradientMode
 *             [, float angle, [bool isAngleScaleable]])
 *         ※ Point, Rectangleも可
 *         
 *         RectangleF  linearGradientBrush.Rectangle { get; }
 *         Color[]     linearGradientBrush.LinearColors
 *         LinearGradientMode   (None Property)
 *           └ enum LinearGradientMode -- System.Drawing.Drawing2D.
 *             {
 *                 Horizontal = 0,      //左から右へのグラデーション
 *                 Vertical = 1,        //上から下へのグラデーション
 *                 ForwardDiagonal = 2, //左上から右下へのグラデーション
 *                 BackwardDiagonal = 3 //右上から左下へのグラデーション
 *             }
 */
 /* 
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainGraphicsPathSample.cs
 *@subject Graphics
 *         void        graphics.DrawPath(Pen, GraphicsPath)
 *         Region      graphics.Clip { get; set;}           Graphicsオブジェクトの描画領域を設定
 *           └ Region      new Region(GraphicPath)
 *         void        graphics.SetClip(Graphics, [CombineMode])
 *         void        graphics.SetClip(Region, [CombineMode])       ※ Rectangle, RectangleF 可
 *         void        graphics.SetClip(GraphicsPath, [CombineMode])
 *           └ enum CombineMode  クリッピング領域の結合方法を指定
 *                     -- System.Drawing.Drawing2D
 *             {
 *                 Replace = 0,    //別のクリッピング領域で置換
 *                 Intersect = 1,  //2つのクリッピング領域は、積集合
 *                 Union = 2,      //2つのクリッピング領域は、両方の和集合
 *                 Xor = 3,        //2つのクリッピング領域は、一方または他方で囲まれた領域だけ
 *                 Exclude = 4,    //既存の領域から新しい領域の差集合で、既存の領域を置換
 *                 Complement = 5  //新しい領域から既存の領域の差集合で、既存の領域を置換
 *             }
 *             
 *         bool        graphics.IsClipEmpty { get; }        Clipプロパティが空か
 *         RectangleF  graphics.ClipBounds { get; }         Clip領域の外接四角形
 *         RectangleF  graphics.VisibleClipBounds  { get; } 表示されているClip領域の外接四角形
 *         bool        graphics.IsVisibleClipEmpty { get; } 表示されているClip領域が 空か
 *         bool        graphics.IsVisible(Rectangle)        引数領域が 表示Clip部分であるか  ※ RectangleF, Point[], PointF[], int, float 可
 *         void        graphics.TranslateClip(int dx, int dy)  Clip領域を平行移動           ※ float可
 *         void        graphics.IntersectClip(Region)       graphicsオブジェクトの既存Clip領域と、引数の領域の交差部分  ※Rectangle, RectangleF
 *         void        graphics.ExcludeClip(Region)         graphicsオブジェクトの既存Clip領域と、引数の領域の差集合    ※Rectangle
 *         void        graphics.ResetClip()                 Clip領域を削除
 *         
 *         ＊配置
 *         void graphics.DrawImage(Image, RectangleF)
 *           └ RectangleF  graphics.VisibleClipBounds
 *               └ Region  　 graphics.Clip
 *                   └ new Region(GraphicPath)
 *                   
 *         例: 
 *         var gPath = new GraphicsPath( ... );
 *         var region = new Region(gPath)
 *         graphics.Clip = region;
 *         graphics.DrawImage(Image, graphics.VisibleClipBounds);
 *         
 *@subject ◆Region : MarshalByRefObject, IDisposable
 *         ・領域を表すオブジェクト
 *         ・集合計算に関するメソッドを持つ
 *         
 *         Region  new Region(GraphicPath)
 *         Region  new Region(※)          ※Rectangle, RectangleF
 *         void    region.Union(※)        和集合  A or B  ※Rectangle, RectangleF, GraphicPath, Region
 *         void    region.Exclude(※)      差集合  A - B
 *         void    region.Intersect(※)    積集合  A and B
 *         void    region.Complement(※)   補集合  not A
 *         void    region.Xor(※)          排他論理和  A xor B (和集合のうち交差部分を除外)
 *         bool    region.Equals(Region region, Graphics g) 一致するか
 *         bool    region.IsEmpty(Graphics g)               空集合であるか
 *         bool    region.IsInfinite(Graphics g)            無限要素であるか
 *         void    region.MakeEmpty()                       Regionを初期化し、空集合にする
 *         
 *@subject ◆GraphicsPath : MarshalByRefObject, ICloneable, IDisposable
 *         ・System.Drawing.Drawing2D 名前空間
 *         ・接続した一連の直線と曲線を表すオブジェクト
 *         ・輪郭に囲まれていれば 必ずRegionになる訳ではない
 *         ・外から偶数個の輪郭を越えて到達できる箇所は，領域外という扱いになります。
 *         
 *         GraphicsPath    new GraphicsPath()
 *         GraphicsPath    new GraphicsPath(FillMode)
 *         GraphicsPath    new GraphicsPath(Point[])   ※PointF[]も可
 *         GraphicsPath    new GraphicsPath(Point[], [byte[] types], [FillMode])
 *           引数  FileMode 
 *             └ enum FileMode  -- System.Drawing.Drawing2D.
 *               {
 *                   Alternate = 0, //交互塗りつぶしモード
 *                   Winding = 1    //全域塗りつぶしモード
 *               }
 *               
 *           引数 byte[] types
 *             └ enum PathPointType -- System.Drawing.Drawing2D.
 *               {
 *                   Start = 0,         //GraphicsPathオブジェクトの始点
 *                   Line = 1,          //線分
 *                   Bezier = 3,        //既定のベジエ曲線
 *                   Bezier3 = 3,       //3次ベジエ曲線
 *                   PathTypeMask = 7,  //マスク ポイント
 *                   DashMode = 16,     //対応するセグメントはダッシュで描画
 *                   PathMarker = 32,   //パス マーカー
 *                   CloseSubpath = 128 //サブパスの終了点
 *               }
 *               
 *               FillMode  graphicsPath.FillMode { get; set; }
 *               PointF[]  graphicsPath.PathPoints { get; }
 *               byte[]    graphicsPath.PathTypes  { get; }
 *               int       graphicsPath.PointCount { get; }   PathTypesの要素数
 *               
 *               void      graphicsPath.AddLine(Point, Point)  ※int, PointF, floatも可
 *               void      graphicsPath.AddLines(Point[])      ※PointF[]も可
 *               void      graphicsPath.AddArc(Rectangle rect, float startAngle, float sweepAngle)  楕円の弧 ※RectangleFも可
 *               void      graphicsPath.AddBeziers(params Point[] points)　                         ３次ベジエ曲線 ※PointF[]
 *               void      graphicsPath.AddCurve(Point[], [int offset, int numberOfSegments], [float tension]) 曲線 ※PointF[]
 *               void      graphicsPath.AddClosedCurve(Point[], [float tension])                    閉じた曲線  ※PointF[]
 *               void      graphicsPath.AddEllipse(Rectangle rect)  ※ RectangleF, floatも可
 *               void      graphicsPath.AddEllipse(int x, int y, int width, int height);
 *               void      graphicsPath.AddPie(Rectangle, float startAngle, float sweepAngle)       扇形 ※RectangleF, float
 *               void      graphicsPath.AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle)
 *               void      graphicsPath.AddPolygon(Point[])              多角形  ※PointF[]
 *               void      graphicsPath.AddRectangle(Rectangle)          四角形  ※RectangleF
 *               void      graphicsPath.AddRectangles(Rectangle[] rect)   四角形の配列  ※RectangleF[]
 *               void AddString(string, FontFamily, int style, float emSize, Point origin, StringFormat)          ※PointF
 *               void AddString(string, FontFamily, int style, float emSize, Rectangle layoutRect, StringFormat); ※RectangleF
 *               void      graphicsPath.AddPath(GraphicsPath, bool connect)  
 *                           引数 connect: 追加パスの最初の図形が、このパスの最後の図形の一部になるか
 *               void      graphicsPath.SetMarkers();      マーカーを設定
 *               void      graphicsPath.ClearMarkers()     すべてのマーカーを消去
 *               void      graphicsPath.CloseAllFigures()  開いている すべての図形を閉じて、新しい図形を開始。開いている図形の開始点と終了点を接続することで閉じた図形になる
 *               void      graphicsPath.CloseFigures()     開いている 現在の図形を閉じて、新しい図形を開始。開いている図形の開始点と終了点を接続することで閉じた図形になる
 *               void      graphicsPath.Reset()            PathPoints, PathTypes配列を空にする。FileMode.Alternateに設定。
 *               void      graphicsPath.Dispose()          このオブジェクトで利用している すべてのリソースを解放
 */
/* 
 *@title WinFormGUI / WinFormSample / ReverseReference / RR08_Graphics
 *@class MainPathGradientBrushSample.cs
 *@subject ◆PathGradientBrush : Brush -- System.Drawing.Drawing2D
 *         ・コンストラクタで 塗りつぶし範囲を指定
 *         ・色情報は コンストラクタに入っていないので、
 *           CenterColor, SurroundColorsを追加で指定する必要がある
 *           (コンストラクタで生成したオブジェクトのままだと何も描画されない)
 *           
 *         PathGradientBrush     new PathGradientBrush(GraphicsPath, [WrapMode])
 *         PathGradientBrush     new PathGradientBrush(Point[], [WrapMode])  ※Point[]も可
 *           └ enum WrapMode  -- System.Drawing.Drawing2D.  塗りつぶし範囲より Brush範囲が小さい場合の並べ方
 *             {
 *                 Tile = 0,        //グラデーションまたはテクスチャを並べて表示
 *                 TileFlipX = 1,   //水平方向に反転し、並べて表示
 *                 TileFlipY = 2,   //垂直方向に反転し、並べて表示
 *                 TileFlipXY = 3,  //水平および垂直方向に反転し、並べて表示
 *                 Clamp = 4        //並べて表示されません
 *             }
 *             
 *         Color       pathGradientBrush.CenterColor { get; set; }    塗りつぶし範囲の中央の色  
 *         Color[]     pathGradientBrush.SurroundColors { get; set; } 塗りつぶし範囲の path周辺の色
 *         RectangleF  pathGradientBrush.Rectangle { get; }           塗りつぶしpathに外接する四角形
 *         PointF      pathGradientBrush.CenterPoint { get; set; }    グラデーションの中央点
 *         WrapMode    pathGradientBrush.WrapMode { get; set; }       塗りつぶし範囲より Brush範囲が小さい場合の並べ方
 *
 *@NOTE【考察】PictureBox.Size と Dock, SizeMode
 *      ・BorderStyle, Imageは Dock, SizeModeで拡大されるが 
 *        Graphicsの描画は Dock, SizeModeで拡大しない
 *        
 *      ・DockStyle.Fill, SizeMode = PictureBoxSizeMode.Zoomなどは
 *        pictureBox.Imageで Imageオブジェクトを登録した場合のみ有効
 *        
 *      ・pictrureBox.CreateGraphics()に g.DrawXxxx()/g.FillXxxx()した
 *        グラフィックスには Dock, SizeModeの値が影響しない
 *        (サイズが小さいまま表示される)
 *        
 *      ・Graphicsを PictureBoxの枠線いっぱいに表示するには
 *        pictureBox.Size / ClientSizeを 正しく指定する必要がある
 *        (pic.Size / pic.ClientSizeは DockStyle.Fill, SizeModeで拡大する前の大きさに設定されている)
 *      
 *      ・Size / ClientSizeを定数指定することは望ましくないので、
 *        PictureBoxの親コントロールである Form / Panelのサイズから取得すべき
 *      
 *      ・Panelである TableLayoutPanelも同様に Dock, ColumnStyles, RowStylesで
 *        拡大・縮小する前のサイズが Size, Width, Heightの値になっている
 *        
 *       ＊例
 *      ・form.ClientSize.Width - 5: 親Formの横幅から、PictureBoxの枠線分の 5pxを除いた横幅
 *      ・(int)(form.ClientSize.Height * 0.83): 親Formの高さの 83%の高さ
 *        intキャストは pic.Sizeが int指定なので要キャスト
 *        intキャストなのに、* 0.85 -> * 0.83などの変更も ちゃんとサイズに反映する
 *        (本来の intキャストだと、どちらの値も 0になるはずだが、
 *         元の 0.85などの値がカプセル化されて、型のみ intになっている様子)
 *      ・間に Bitmapオブジェクトを入れて
 *        pic.Image = new Bitmap(pic.Width, pic.Height); として、
 *        pic.CreateGraphics().DrawXxxx()で描いても、Dock, SizeModeは適用されない
 *        
 *      ・Image.FromFile(string fileName), new Bitmap(string)は
 *        Imageの元サイズが どうであれ、デフォルトで決まったサイズで登録される
 *        image.Width, image.Height, image.Sizeは、デフォルトの PictureBoxのサイズになる
 *        => new Bitmap(Image.FromFile(string fileName), Size)で登録すると、
 *        元画像のサイズで登録される
 *        
 *       ・初期画像を表示するには、pic.Imageプロパティを登録
 *         Buttonイベントのメソッドを呼出ても反応しない。
 *         Imageプロパティを登録しても、g.DrawImage()の画像を表示できる。
 *         (ただし、上書きするので、切り替える場合は g.Clear(Color)が必要)
 */
 /* 
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainDrawIconSample.cs
 *@subject Graphics
 *         void  graphics.DrawIcon(Icon, int x, int y)  Iconクラスを指定位置に描画、サイズは Icon のサイズ
 *         void  graphics.DrawIcon(Icon, Rectangle)     Iconクラスを指定位置とサイズで描画
 *         
 *         [×] float, Point, PointF, RectangleF は定義なし
 *
 *@subject フォームのアイコン設定
 *         Icon    form.Icon       フォームのアイコン
 *         bool    form.ShowIcon   フォームのアイコンを表示するか / デフォルト: true
 *         
 *@subject〔WF44〕◆Icon : MarshalByRefObject, ISerializable, ICloneable, IDisposable
 *         Icon   new Icon(string fileName)
 *         Icon   new Icon(Stream stream)
 *         Icon   new Icon(string fileName, Size size)
 *         Icon   new Icon(Icon original, Size size)
 *         Icon   new Icon(Type type, string resource)
 *         Icon   new Icon(Stream stream, Size size)
 *         Icon   new Icon(string fileName, int width, int height)
 *         Icon   new Icon(Icon original, int width, int height)
 *         Icon   new Icon(Stream stream, int width, int height)
 *         
 *         int    icon.Width    { get; }
 *         int    icon.Height   { get; }
 *         Size   icon.Size     { get; }
 *         
 *         Icon   static Icon.ExtractAssociatedIcon(string filename) 画像ファイル(.bmp/.jpgなど)から Iconを作成
 *         void   icon.Save(Stream outputStream)
 *         Bitmap icon.ToBitmap()
 *         
 *         => copyFrom〔RR05_MenuToolStrip/MainNotifyIconSample.cs〕
 *         
 *@subject class SystemIcons --System.Drawing.
 *         ・System32 既定のアイコン
 *         ・enumではく classなので Reflectionを利用して、全プロパティを取得
 *         ・「Windowsアイコン」は ちゃんと描画できない
 *         ・PictureBoxで graphics.DrawIcon()することもできる
 *           =>〔Reference/SystemIconDiv/MainSystemIconSample.cs〕
 *         
 *         public sealed class SystemIcons   
 *         {
 *             static Icon Application { get; }  WIN32: IDI_APPLICATION
 *             static Icon Asterisk { get; }     WIN32: IDI_ASTERISK
 *             static Icon Error { get; }        WIN32: IDI_ERROR
 *             static Icon Exclamation { get; }  WIN32: IDI_EXCLAMATION
 *             static Icon Hand { get; }         WIN32: IDI_HAND
 *             static Icon Information { get; }  WIN32: IDI_INFORMATION
 *             static Icon Question { get; }     WIN32: IDI_QUESTION
 *             static Icon Warning { get; }      WIN32: IDI_WARNING
 *             static Icon WinLogo { get; }      WIN32: IDI_WINLOGO
 *             static Icon Shield { get; }       シールド アイコン
 *         }
 */
 /*
 *@title WinFormGUI / WinFormSample / KaiteiNet.KT07_Graphics
 *@class MainBitmapGetPixelSample.cs
 *@subject ◆abstract Image : MarshalByRefObject, ISerializable, ICloneable, IDisposable
 *         [×]      new Image()
 *         Image    Image.FromFile(string fileName)
 *         Image    Image.FromStream(Stream)
 *         
 *         int      image.Width   { get; }
 *         int      image.Height  { get; }
 *         Size     image.Size    { get; }
 *         ImageFormat  image.RawFormat   { get; }
 *         PixelFormat  image.PixelFormat { get; }
 *           └ enum PixelFormat { ... }   カラーのデータ形式
 *           
 *         void     image.RotateFlip(RotateFlipType)        画像の回転、反転
 *           └ enum RotateFlipType { ... }   =>〔MainDrawImageSample.cs〕
 *         void     image.Save(string filename, ImageFormat format);
 *         void     image.Save(Stream stream, ImageFormat format);
 *           └ class ImageFormat -- System.Drawing.Imaging.ImageFormat
 *             ImageFormat   new ImageFormat(Guid guid)
 *             Guid          ImageFormat.Guid { get; }   GUID (Grobal Unique Identifer) グローバル 一意の識別子 ??
 *               └ struct System.Guid 構造体
 *             ImageFormat   ImageFormat.MemoryBmp { get; }   メモリ上のビットマップの形式
 *             ImageFormat   ImageFormat.Bmp  { get; }   ビットマップ (BMP) イメージ形式
 *             ImageFormat   ImageFormat.Emf  { get; }   拡張メタファイル (EMF) イメージ形式
 *             ImageFormat   ImageFormat.Wmf  { get; }   Windows メタファイル (WMF) イメージ形式
 *             ImageFormat   ImageFormat.Gif  { get; }   GIF (Graphics Interchange Format) イメージ形式
 *             ImageFormat   ImageFormat.Jpeg { get; }   JPEG (Joint Photographic Experts Group) イメージ形式
 *             ImageFormat   ImageFormat.Png  { get; }   W3C PNG (Portable Network Graphics) イメージ形式
 *             ImageFormat   ImageFormat.Tiff { get; }   TIFF (Tagged Image File Format) イメージ形式
 *             ImageFormat   ImageFormat.Exif { get; }   Exif (Exchangeable Image File) 形式
 *             ImageFormat   ImageFormat.Icon { get; }   Windows アイコン イメージ形式
 *         
 *         void     image.Dispose();
 *         
 *@subject ◆Bitmap : Image
 *         ・ピクセルデータで表現されるイメージを扱うクラス
 *         ・abstract Image クラスを継承
 *         ・BMP 形式以外に JPG，GIF，PNG，EXIF，TIFF 形式も可。
 *         ・Bitmap オブジェクトでは，1 ピクセルごとに色の情報を得ることができる。
 *         ・Bitmap オブジェクトなら，1 ピクセルごとに色を操作することができる。
 *         
 *         Bitmap   new Bitmap(string fileName)
 *         Bitmap   new Bitmap(Stream)
 *         Bitmap   new Bitmap(Image original)
 *         Bitmap   new Bitmap(Image original, Size newSize)
 *         Bitmap   new Bitmap(string fileName, bool useIcm)   
 *         Bitmap   new Bitmap(Stream stream, bool useIcm)
 *         Bitmap   new Bitmap(Type type, string resource)
 *         Bitmap   new Bitmap(int width, int height)
 *         Bitmap   new Bitmap(int width, int height, PixelFormat format)
 *         Bitmap   new Bitmap(int width, int height, Graphics g)
 *         Bitmap   new Bitmap(Image original, int width, int height)
 *         Bitmap   new Bitmap(int width, int height, int stride, PixelFormat, IntPtr scan0)
 *           引数 bool useIcm: 色補正を利用するか
 *                int stride: スキャンラインの間のバイトオフセット数を指定する整数。 
 *                            これには、通常 (必須ではありません)、ピクセルあたりのバイト数という形式 
 *                            (16 ビット/ピクセルの場合は 2) にビットマップの幅を乗じた値を指定します。
 *                            このパラメーターに渡す値は、4 の倍数である必要があります。
 *                IntPtr scan0: ピクセル データを格納するバイトの配列へのポインター。
 *               
 *         Color    graphics.GetNearestColor(Color color)  引数に最も近い Color structを取得
 *         Color    bitmap.GetPixel(int x, int y)          ピクセル座標を指定して Colorを取得
 *         void     bitmap.SetPixel(int x, int y, Color)   ピクセル座標を指定して Colorを設定
 *         void     bitmap.MakeTransparent()               既定の透過色を透明にする
 *         void     bitmap.MakeTransparent(Color)          透過色を指定して、その色を透明にする
 */
 /*
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainBitmapMakeTransparentSample.cs
 *@subject 【部分透過】 画像を透過させて重ねる方法
 *         ・PNG形式「.png」の画像は 透過度情報をデータ内に保持している
 *         ・背景が透明の PNGを利用するか
 *         ・背景が一色に塗られている画像で、MakeTransparent()で透過色を指定する
 *         ・MakeTransparent()で指定した色を背景以外で利用していた場合、そこも透明になってしまう
 *         ・背景が透明の画像のほうが、きれいに描画できる
 *         
 *@subject Bitmap =>〔MainBitmapGetPixelSample.cs〕
 *         void    bitmap.MakeTransparent()       既定の透過色を透明にする
 *         void    bitmap.MakeTransparent(Color)  透過色を指定して、その色を透明にする
 *         Color   bitmap.GetPixel(int x, int y)  指定座標の Colorを取得
 */
 /*
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainBitmapSetPixcelSample.cs
 *@content KT07 Graphics / Bitmap.SetPixcel()
 *         Bitmap   new Bitmap(int width, int height) によって、
 *         サイズだけ指定した 空のBitmapオブジェクトを作り、
 *         bitmap.SetPixel(int x, int y, Color)で、
 *         Bitmapの絵を描き、
 *         graphic.DrawImage(Image, int x, int y)で
 *         Bitmapを Formに描画
 *         SetPixel()を変更した場合は form.Reflesh()で再描画が必要
 *         
 *@subject Bitmap =>〔MainBitmapGetPixelSample.cs〕
 *         void    bitmap.SetPixcel(int x, int y, Color)
 *         
 *@subject Color  =>〔~/WinFormSample/ColorReference.txt〕
 *         Color   Color.FromArgb(int red, int green, int blue)
 *
 *@NOTE【註】
 *      ・for文 i, j, k での 三重ネストは 処理に 1-2分ぐらい掛かり、
 *        表示が停滞する
 *      ・bitmap.SetPixel()だけでは、Formの表示に変化なし
 *        form.Reflesh()でキャッシュを破棄し、再描画すると Formに反映する
 */
  /*
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainDrawImageSample.cs
 *@subject Graphics
 *         void   graphics.DrawImage(Image, int x, int y)
 *         void   graphics.DrawImage(Image, float x, float y)
 *         void   graphics.DrawImage(Image, int x, int y, int width, int height)
 *         void   graphics.DrawImage(Image, float x, float y, float width, float height)
 *         
 *         ※ Point, PointF, Point[], PointF[], Rectangle, RectangleFを用いる オーバーロード(全29個)もある
 *         ※ enum GraphicsUnit 長さの単位を指定する引数もある
 *            {
 *                World = 0,      //ワールド座標系を長さの単位に指定
 *                Display = 1,    //表示デバイスの長さの単位を指定します。 通常、ビデオ ディスプレイにはピクセル、プリンターには 1/100 インチを指定します。
 *                Pixel = 2,      //デバイス ピクセルを長さの単位
 *                Point = 3,      //プリンターポイント (1/72 インチ) を長さの単位に指定
 *                Inch = 4,       //インチを長さの単位に指定
 *                Document = 5,   //ドキュメント単位 (1/300 インチ) を長さの単位に指定
 *                Millimeter = 6  //ミリメートルを長さの単位に指定
 *            }
 *            
 *@subject abstract Image : MarshalByRefObject, ISerializable, ICloneable, IDisposable
 *         ・抽象クラス Image: new Image()は不可
 *         ・インスタンスは Bitmapオブジェクトを生成している〔KT07〕
 *         ・=>〔MainBitmapGetPixelSample.cs〕
 *         
 *         Image  Image.FromFile(string path)       static / ファイルからImageをロード
 *         void   image.RotateFlip(RotateFlipType)  回転と反転のタイプを適用
 *           └ enum RotateFlipType
 *             {
 *                 RotateNoneFlipNone = 0,  //回転も反転も行わない
 *                 Rotate180FlipXY = 0,     //時計回りに 180 度回転してから、水平と垂直に反転
 *                 Rotate90FlipNone = 1,    //反転せずに時計回りに 90 度回転
 *                 Rotate270FlipXY = 1,     //時計回りに 270 度回転してから、水平と垂直に反転
 *                 Rotate180FlipNone = 2,   //反転せずに時計回りに 180 度回転
 *                 RotateNoneFlipXY = 2,    //回転せずに水平と垂直に反転
 *                 Rotate270FlipNone = 3,  //反転せずに時計回りに 270 度回転
 *                 Rotate90FlipXY = 3,   //時計回りに 90 度回転してから、水平方向と垂直方向に反転
 *                 RotateNoneFlipX = 4,  //回転せずに水平方向に反転
 *                 Rotate180FlipY = 4,   //時計回りに 180 度回転してから、垂直方向に反転
 *                 Rotate90FlipX = 5,    //時計回りに 90 度回転してから、水平方向に反転
 *                 Rotate270FlipY = 5,   //時計回りに 270 度回転してから、垂直方向に反転
 *                 Rotate180FlipX = 6,   //時計回りに 180 度回転してから、水平方向に反転
 *                 RotateNoneFlipY = 6,  //回転せずに垂直方向に反転
 *                 Rotate270FlipX = 7,   //時計回りに 270 度回転してから、水平方向に反転
 *                 Rotate90FlipY = 7     //時計回りに 90 度回転してから、垂直方向に反転
 *             }
 *             
 *@NOTE【考察】画像の反転
 *      ・KTのコード image.RotateFlip(RotateFlipType.RotateNoneFlipX)では反転しない
 *      ・RRのコード graphics.DrawImage()の 
 *        * 反転したい Width/Heightを マイナスにして反転する方法
 *        * -Widthにすると、DrawImageの開始点より左に描画され反転するので
 *          開始点を image.Width分 右にずらして置く必要がある。
 *          
 *        * マイナスにする方法で意図どうりの結果となるが、
 *          ２箇所(開始点と画像サイズ)を変更する必要があり、
 *          保守性,可読性に欠くので、できれば避けたいコード
 *        
 *        *image.RotateFlip()の解決方法を探すべき
 *          ・KT サンプルコードの (int) (image.Width * 0.8)は 関係がない。
 *            intでも floatでも DrawImage()は機能する
 *          ・imageRotated.RotateFlip(RotateFlipType.RotateNoneFlipX)を
 *            DrawImage(imageRotated, ...)の後に置いても解決せず。
 *          ・form.Refresh()を OnPaint()内に記述 
 *            => 解決せず。画面が何度も Refresh()されチラつく
 *          ・CommandPromptで実行 => 解決せず。([Visual C#]が原因ではない)
 *          ・ネットには [Windows Form]に同様の不具合報告あり。原因不明
 */
/* 
 *@title WinFormGUI / WinFormSample / ReverseReference / RR08_Graphics
 *@class MainColorMatrixSemiTransParent.cs
 *@content RR[371] p625 ColorMatrix SemiTransParent
 *         画像を半透明にして描画
 *         semitransparent [英]: 半透明な
 *         translucent  [英]: 半透明な, 透明感
 *         translucency [英]: 透明度, 透明性, 透過性
 *         matrix [英]: 行列
 *         
 *@subject Graphics
 *         void  graphics.DrawImage(
 *                 Image, Rectangle destRect, Rectangle srcRect, GraphicsUnit)
 *                   └ 引数 destRect: 描画する位置とサイズを四角形で指定
 *                     引数 srcRect:  描画するImageの部分画像の範囲を四角形で指定
 *                 ※ RectangleFも可、int, float, Point[], PointF[]に置換するオーバーロードあり
 *                 ※ 元画像　srcRect -> 表示領域 destRectの比率で自動的に拡大縮小
 *                 (= g.DrawImageに SizeModeは作用しないが、PictrueBoxSizeMode.StretchImage と同様の結果)
 *                 
 *         void  graphics.DrawImage(
 *                 Image, Rectangle, int x, int y, int width, int height,
 *                 GraphicsUnit, ImageAttributes)
 *                   └ enum GraphicsUnits =>〔KT07_Graphics/MainDrawImageSample.cs〕
 *                 ※ RectangleF不可, floatも可
 *                 
 *         [×] System.NotImplementedException: 実装されていません。(VSのコンパイルは通る)
 *         void  graphics.DrawImage(
 *                 Image, PointF[] destPoints, RectangleF srcRect,
 *                 GraphicsUnit, ImageAttributes)
 *                 ※ Point[]不可, Rectangle不可
 *         ※表示位置の PointF[]が利用できないため、倍率による拡大縮小ができない
 *         
 *@subject ImageAttributes : ICloneable, IDisposable
 *            -- System.Drawing.Imaging.
 *         ImageAttributes   new ImageAttributes()
 *         
 *         void  imageAttr.SetColorMatrix(ColorMatrix)          色調変更のColorMatrixを設定
 *         void  imageAttr.SetColorMatrix(ColorMatrix, [ColorMatrixFlag, [ColorAdjustType]])
 *         void  imageAttr.ClearColorMatrix([ColorAdjustType])  指定した型のColorMatrixを削除
 *           └ enum  ColorMatrixFlag
 *             {
 *                 Default = 0,   //すべてのカラー値 (灰色の網かけを含む) が同じカラー調整行列によって調整
 *                 SkipGrays = 1, //色はすべて調整、灰色の網かけは調整されません。 灰色の網かけは、赤、緑、青の各要素の値が同じである色。
 *                 AltGrays = 2   //灰色の網かけのみ調整
 *             }
 *             
 *           └ enum ColorAdjustType      色調整する型を選択。部分的な色調整ができる
 *             {
 *                 Default = 0, //独自の色の調整情報がないすべての GDI+ オブジェクトにより使用される色の調整情報
 *                 Bitmap = 1,  //Bitmap オブジェクトの色の調整情報
 *                 Brush = 2,   //Brush オブジェクトの色の調整情報
 *                 Pen = 3,     //Pen オブジェクトの色の調整情報
 *                 Text = 4,    //テキストの色の調整情報
 *                 Count = 5,   //指定した型の数
 *                 Any = 6      //指定した型の数
 *             }
 *         
 *         void  bitmap.MakeTransparent(Color)                透過色を指定して、その色を透明にする
 *         void  imageAttr.SetColorKey(                       透過色の範囲や型を指定して、その色を透明にする
 *                 Color colorLow, Color colorHigh, [ColorAdjustType])    
 *         void  imageAttr.ClearColorKey([ColorAdjustType]);  型を指定した ColorKeyを削除
 *         
 *         void  imageAttr.SetNoOp([ColorAdjustType type])    指定した型の 色調整を停止。SetOnOp()呼出前に戻す
 *         void  imageAttr.ClearNoOp([ColorAdjustType type])  SetOnOp()で停止していた 色調整を元に戻す
 *
 *         void  imageAttr.SetBrushRemapTable(ColorMap[] map)            Brush型のカラー リマップ テーブルを設定
 *           └ class ColorMap -- System.Drawing.Imaging.
 *             ColorMap   new ColorMap()
 *             Color      colorMap.OldColor { get; set; }
 *             Color      colorMap.NewColor { get; set; }
 *         void  imageAttr.ClearBrushRemapTable()                
 *         void  imageAttr.SetRemapTable(ColorMap[], [ColorAdjustType])  指定した型のカラー リマップ テーブルを設定
 *         void  imageAttr.ClearRemapTable([ColorAdjustType type])
 *
 *         void  imageAttr.SetWrapMode(WrapMode mode, Color color)
 *           └ enum WrapMode  -- System.Drawing.Drawing2D.  塗りつぶし範囲より Brush範囲が小さい場合の並べ方
 *             {
 *                 Tile = 0,        //グラデーションまたはテクスチャを並べて表示
 *                 TileFlipX = 1,   //水平方向に反転し、並べて表示
 *                 TileFlipY = 2,   //垂直方向に反転し、並べて表示
 *                 TileFlipXY = 3,  //水平および垂直方向に反転し、並べて表示
 *                 Clamp = 4        //並べて表示されません
 *             }
 *             
 *@subject ◆ColorMatrix class -- System.Drawing.Imaging.
 *         ・RGBAW空間の 5 × 5 行列を表すクラス
 *         ・R: Red / G: Green / B: Blue / A: Alpha 透明度 / W: ?? を表す
 *         ・ImageAttributesクラスの コンストラクタの引数やプロパティの値として利用
 *         
 *         ＊透明度の変更 Matrix33 = XXf;  
 *           XX は [0 ～ 1]の float値   0f:透明, 0.xf: 半透明, 1f:不透明
 *           
 *         ＊色調の変更 RR[372] p626
 *           変更後の R = r * Matrix00 + g * Matrix01 + b * Matrix02
 *           変更後の G = r * Matrix10 + g * Matrix11 + b * Matrix12
 *           変更後の B = r * Matrix20 + g * Matrix21 + b * Matrix22
 *         
 *         ColorMatrix   new ColorMatrix();
 *         ColorMatrix   new ColorMatrix(float[][] newColorMatrix)
 *         
 *         float colorMatrix[int row, int column]
 *         float this[int row, int column]
 *         float colorMatrix.MatrixXX       XX: row-column, 0-4
 *         例: colorMatrix.Matrix33 = 0.5f; とすると半透明の画像になる
 */
/** 
 *@title WinFormGUI / WinFormSample / ReverseReference / RR08_Graphics
 *@class MainMatrixRotateSample.cs 
 *@content RR[374][378] Matrixクラス RotateAt(), Scale() / p630, p635
 *         matrix    [英]: 行列
 *         geometric [英]: 幾何学
 *         geometry transformation [数]: 
 *             幾何学的変換, ジオメトリック変換
 *             3Dグラフィックスの処理
 *             多角形の座標データを、描画(表示)のためのデータに変換すること
 *             
 *@subject Graphics
 *         Matrix   greaphics.Transform { get; set; }   図形の変換をする行列(matrix)を取得/設定
 *         例 matrix.RotateAt(...);など変更のたびに
 *            graphics.Transform = matrix; と代入しないと変更を反映しない
 *            (graphics.Flush(), form.Refresh()では不可)
 *
 *         void     graphics.RotateTransform(float angle, [MatrixOrder])           Transformで登録した Matrixを指定角度と順序で回転
 *         void     graphics.ScaleTransform(float sx, float sy, [MatrixOrder])     Transformで登録した Matrixを指定倍率と順序で拡大縮小
 *         void     graphics.TranslateTransform(float dx, float dy, [MatrixOrder]) Transformで登録した Matrixを指定幅と順序で平行移動
 *         void     graphics.ResetTransform()                                      変換行列 Matrixを削除
 *         
 *@subject ◆Matrix : MarshalByRefObject, IDisposable
 *            -- System.Drawing.Drawing2D.
 *         ・図形の回転(360°内で時計回りの角度を指定可), 反転, 拡大縮小を行う変換行列を表すクラス
 *         ・void     image.RotateFlip(RotateFlipType)   90°単位の回転, 反転
 *         ・複数回の変換を行うと、内部的に 行列を乗算している様子
 *         
 *         Matrix   new Matrix()
 *         Matrix   new Matrix(Rectangle, Point[])
 *            変換する四角形と、ジオメトリック変換〔上記〕の変換先の平行四辺形
 *            ※ RectangleF, PointF[], float可
 *         
 *         void  matrix.Rotate(float angle, [MatrixOrder])             角度を指定して原点(0, 0)を中心とする回転
 *         void  matrix.RotateAt(float angle, PointF, [MatrixOrder])   角度と中心点を指定して回転
 *           └ enum MatrixOrder -- System.Drawing.Drawing2D.
 *             {
 *                 Prepend = 0,  //新しい操作が、古い操作の前に適用
 *                 Append = 1    //新しい操作が、古い操作の後に適用
 *             }
 *         bool  matrix.IsInvertible { get; }    反転可能か
 *         void  matrix.Invert()                 反転可能なら反転
 *         void  matrix.Translate(float offsetX, float offsetY, [MatrixOrder]) x方向, y方向に平行移動
 *         void  matrix.Shear(float shearX, float shearY, [MatrixOrder])  画像原点(0, 0)を基準に x方向, y方向の傾斜率を指定して傾斜
 *         void  matrix.Scale(float scaleX, float scaleY, [MatrixOrder])  x方向, y方向の拡大率を指定して拡大縮小
 *         void  matrix.Multiply(Matrix, [MatrixOrder])                   対象オブジェクトの行列に、引数の行列を乗算
 *         float[]  matrix.Elements { get; }   Matrixの要素である float[]を取得
 *         bool     matrix.IsIdentity { get; } 単位行列であるか
 *         void     matrix.Reset()             単位行列の要素を持つようにリセット
 *                   ※単位行列 unit matrix: 
 *                     https://kotobank.jp/word/%E5%8D%98%E4%BD%8D%E8%A1%8C%E5%88%97-94854
 *                     ・n 次の正方行列 A＝(aij) において，
 *                       主対角線上の要素がすべて 1で，その他はすべて 0であるもの
 *                     ・行列は乗算の順によって解が異なるが
 *                       単位行列を E とすれば AE＝EA＝A なる関係が成り立つ
 *                       | 1 0 |   | 1 0 0 |
 *                       | 0 1 | , | 0 1 0 | , ... のような要素になっている。
 *                                 | 0 0 1 |
 *         
 *@NOTE【考察】回転の中心点と、描画の原点
 *      ・PictureBoxSizeMode.CenterImage を設定しているので、
 *        ここでは PictureBox.ClientSizeの中心点と、画像の中心点は一致する
 *      ・回転の中心点を 上記に設定
 *      
 *        centerPoint = new Point(
 *             pic.ClientSize.Width / 2, pic.ClientSize.Height / 2);
 *
 *      ・画像描画の原点を指定する必要があるので
 *        PictureBoxの中心点だと、画像が ずれていく。
 *        PictureBoxの中心点から、画像の横幅 / 2 と高さ /2 の差を 描画の原点とする
 *        
 *        g.DrawImage(image, new Point(                     
 *           (pic.ClientSize.Width - image.Width) / 2,
 *           (pic.ClientSize.Height - image.Height) / 2));
 */
 /*
 *@title WinFormGUI / WinFormSample / ReverseReference / RR08_Graphics
 *@class MainMatrixScaleTaranslate.cs
 *@content RR[378] p635 Matrixクラス Scale(), Taranslate()
 *         画像の拡大縮小、平行移動
 *         => 〔MainMatrixRotateSample.cs〕
 *           
 *@NOTE【Problem】Matrixクラス Scale(), Translate()
 *      ・matrix.Scale()によって、元画像の縦横比を維持したまま、
 *        PictureBoxのサイズに拡大縮小することには成功
 *      ・matrix.Translate()でセンタリングを試みたが、intキャスト時の誤差のためか
 *        元画像のサイズによって、表示位置が変わってしまう問題あり〔未解決〕
 *        
 *      ・Matrix利用前は
 *        rect = new Rectangle(0, 0, pic.Width, pic.Height); で うまくいっていたが
 *      ・Matrix利用後は
 *        rect = new Rectangle(0, 0, image.Width, image.Height);でないと
 *        Scale()の倍率が大幅にずれてしまう問題あり。
 *        image.Width, image.Heightで Matrix修正後のサイズになっている様子
 *      
 *      ・double計算の精度を上げるため、decimalで計算
 *        decimal  Math.Round(decimal, int)  int値は小数点以下 第何位に丸めるか
 *        小数点以下 2 -> 4に変更すると、うまくいかない。
 *        
 *      private void BuildTransform()
        { 
            decimal widthRate = Math.Round(
                (decimal)pic.ClientSize.Width / (decimal)image.Width, 2);
            decimal heightRate = Math.Round(
                (decimal)pic.ClientSize.Height / (decimal)image.Height, 2);
            decimal adjustRate = (widthRate < heightRate) ? widthRate : heightRate;

            Matrix mx = new Matrix();
            mx.Scale((float)adjustRate, (float)adjustRate);
            mx.Translate(
                (float)((pic.ClientSize.Width - image.Width * adjustRate) / 2),
                (float)((pic.ClientSize.Height - image.Height * adjustRate) / 2));

            g.Transform = mx;
        }//BuildTransform()
*/
/*
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainMouseDragSample.cs
 *@content KT07 Graphics / MouseDragSample
 *         マウス ドラッグによる画像の移動
 *         ・PictureBoxに画像を載せる
 *         ・pictureBox.MouseDown, MouseUp, MouseMoveイベントだけで
 *           マウスドラッグを表現できる
 *
 *@subject ドラッグ移動
 *         ・現地点からドラッグ移動分だけ PictureBoxの開始点を移動させる
 *         ・PictureBoxの幅, 高さは考慮する必要がない
 *           control.Top, Bottom, Left, Right で 四辺の座標を取得/設定できる
 *           (form.AutoSize = true; になっているなら、自動でFormが拡大する)
 *         
 *          if (dragged)
 *          {
 *              pictureBox.Left += e.Location.X - dragPoint.X;
 *              pictureBox.Top += e.Location.Y - dragPoint.Y;
 *          }
 */
 /*
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainTimerAnimationSample.cs
 *@subject アニメーション
 *         ＊描画
 *         ・Timer -> Timer.Tickイベント
 *         ・Rectangel -> FillXxxx(), DrawXxxx()
 *         Timerで 一定時間ごとに再描画
 *         座標処理は Rectangleの始点(左上の座標)で行う
 *         図形幅も考慮して座標を判定すべし
 *         
 *         ＊前図形の削除と新図形の再描画
 *         void   control.Invalidate();
 *
 *         ＊ダブル・バッファー
 *         bool   control.DoubleBuffered   
 *           ・画面のチラつきを抑制するためにダブルバッファーを使用するか
 *           ・頻繁に再描画する場合に利用する
 *           ・この画面のチラつきは，コンピュータが描画をしている様子が，
 *             そのまま見えてしまっていることが原因です。
 *             軽減するためには，一旦メモリ上のキャンバスで描画を完成させ，
 *             完成した描画を画面に表示するようにします。
 *             
 *@NOTE【考察】Formの Size, ClientSize
 *      Formのサイズは、X座標, Y座標に 見えていない余分の幅が存在し、
 *      Size = 見えている幅 + 見えていない余分の幅 
 *      ClientSize = 見えている幅
 *      
 *      おそらくTitleBar, ScrollBar, StatusBarの幅が Formのサイズになっている。
 *      可視範囲の Formの枠で座標処理する場合は ClientSizeで処理すべし
 */
/*
 *@title WinFormGUI / WinFormSample / KaiteiNet / KT07_Graphics
 *@class MainBallGravity.cs
 *@content KT07 Graphics / BallGravity
 *         ボールの画像に重力を働かせ自然落下し、バウンドさせる
 *         behaivior [英] 動作, 挙動, 振る舞い
 *         gravity [英]   重力
 *
 *@based   MainMouseDragSample.cs
 *@subject 重力, バウンド  / parent: Form, base: PictureBox
 *         private double velocity = 0d;  //速度
 *         private double accel = 0.5d;   //加速度
 *         
 *         private void timer_Tick(object sender, EventArgs e)
 *         {
 *             //---- Gravity / 重力 ----
 *             velocity += accel;           //速度を徐々に加速
 *             base.Top += (int)velocity;   //Top座標を速度分だけ落下「+=」
 *
 *             //---- Bound / バウンド ----
 *             if(base.Bottom >= parent.ClientSize.Height)  //底に着いたら
 *             {
 *                 velocity *= -0.8;                        //速度を 80%に減速
 *                 base.Top = parent.ClientSize.Height - base.Height;  
 *                                                          //ボールの高さ分だけ底から上げる
 *             }
 *         }//timer_Tick()
 *
 *@NOTE【調整】Padding
 *      control.Padding = new Padding(5);
 *      Padding: コントロール内側の余白
 *      ドラッグ時や、重力移動時に再描画のチラつきでボールが欠けるので
 *      内側周囲に 5pxずつの余白を挿入
 *      底に着いたときも Padding分の余白ができるので注意
 */